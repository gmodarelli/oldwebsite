<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Explaining Source Code: Dotenv part 2 | Giuseppe Modarelli</title>

    <!-- Bootstrap -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous">

<!-- Base -->
<link rel="stylesheet" href="/css/base.css">

<!-- Github Flavored Markdown Style -->
<link rel="stylesheet" href="/github-markdown-css/github-markdown.css">

<!-- Github Code Highlight -->
<link rel="stylesheet" href="/node_modules/highlight.js/styles/github.css">
  </head>

  <body>
    <nav class="navbar navbar-inverse navbar-fixed-top">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Giuseppe Modarelli</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
    </div><!--/.navbar-collapse -->
  </div>
</nav>

    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <h1><a href="/2015/01/esc_dotenv_pt2">Explaining Source Code: Dotenv part 2</a></h1>
          <h6>February 12, 2015</h6>

          <article class="markdown-body">
            <p>Last week we begun <a href="/2015/02/esc_dotenv_pt1/">a journey through the source code</a> of the
<a href="https://github.com/bkeepers/dotenv">Dotenv</a> gem. Today we’re gonna continue that journey.</p>
<p>Last time we stopped right before jumping into the Environment class, so let’s begin reading it.</p>
<pre><code class="language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Dotenv</span></span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Environment</span> &lt; Hash</span>
    <span class="hljs-keyword">attr_reader</span> <span class="hljs-symbol">:filename</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(filename)</span></span>
      @filename = filename
      load
    <span class="hljs-keyword">end</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load</span></span>
      update Parser.call(read)
    <span class="hljs-keyword">end</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span></span>
      File.read(@filename)
    <span class="hljs-keyword">end</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>
      each { |k,v| ENV[k] ||= v }
    <span class="hljs-keyword">end</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply!</span></span>
      each { |k,v| ENV[k] = v }
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This class inherits from the ruby <code>Hash</code> class. It does so because the environment is nothing but a
<em>key-value storage</em> where we store, for instance, tokens and secrets to access external services,
and then we fetch them through the <code>ENV</code> hash.</p>
<p>We initialize an object of this class with a file (for example the default .env file) and then call the
<code>load</code> method. The <code>load</code> method, in turns, calls the <code>update</code> method passing in the result of the call
to <code>Parser.call(read)</code>.
For now just keep in mind that the <code>Parser.call</code> method takes in the content of the file and
parses it into a hash. We won’t read the <code>Parser</code> class together.
You can read it as an exercise and you will learn something useful about <code>regular expressions</code>!</p>
<p>The <a href="http://ruby-doc.org/core-2.2.0/Hash.html#method-i-update"><code>update</code></a> method is a method of the <code>Hash</code>
class and it merges two hashes together.
In fact it is an alias for <code>merge</code>. So the <code>load</code> method merges the hash returned by the <code>Parser</code>
into itself (remember, <code>Environment</code> is a <code>Hash</code>).</p>
<p>We have other two important methods defined in this class, the <code>apply</code> and <code>apply!</code> methods.</p>
<p>Inside these two methods is where the magic of Dotenv happens. Let’s take a look at the <code>apply</code> method first,
and then we’ll see how it differs from the <code>apply!</code> one.</p>
<pre><code class="language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>
  each { |k,v| ENV[k] ||= v }
<span class="hljs-keyword">end</span>
</code></pre>
<p>It’s just one line of code. The method calls <code>each</code> – and since there’s no <code>each</code> method defined on this
class, it is calling the <code>each</code> defined on the <code>Hash</code> class – passing it a block.</p>
<p><code>each</code> iterates over all the key-value pairs of the hash and the block sets the value of a key inside the
<code>ENV</code> variable, only if it is not already set. It does so using the <code>||= (or equal) operator</code>.
And this is where <code>apply</code> differs from <code>apply!</code>. The latter overrides an existing key with the new value.</p>
<pre><code class="language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>
  each { |k,v| ENV[k] = v }
<span class="hljs-keyword">end</span>
</code></pre>
<p>To see how these two methods are used, let’s go back to the <code>dotenv.rb</code> file. Here are the important bits:</p>
<pre><code class="language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Dotenv</span></span>
  extend <span class="hljs-keyword">self</span>

  <span class="hljs-keyword">attr_accessor</span> <span class="hljs-symbol">:instrumenter</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load</span><span class="hljs-params">(*filenames)</span></span>
    with(*filenames) <span class="hljs-keyword">do</span> |f|
      <span class="hljs-keyword">if</span> File.exist?(f)
        env = Environment.new(f)
        instrument(<span class="hljs-string">'dotenv.load'</span>, <span class="hljs-symbol">:env</span> =&gt; env) { env.apply }
      <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-comment"># ...</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">instrument</span><span class="hljs-params">(name, payload = {}, &amp;block)</span></span>
    <span class="hljs-keyword">if</span> instrumenter
      instrumenter.instrument(name, payload, &amp;block)
    <span class="hljs-keyword">else</span>
      block.call
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>On line 10 we call the <code>instrument</code> method, and we provide a block. Inside this block we call the <code>apply</code>
method on the <code>env</code> variable (an instance of the <code>Environment</code> class). As you can see from the <code>instrument</code>
method we execute the block only if an <code>instrumenter</code> is not provided. It is using the block to provide
a default behaviour.</p>
<p>You will find this pattern everywhere in Ruby. For example it is used by the
<a href="http://ruby-doc.org/core-2.2.0/Hash.html#method-i-fetch">Hash#fetch</a> method to provide a default value
when the key you are trying to access is missing.</p>
<p>In simple situations, like a simple ruby app, or even a Sinatra app, this default behaviour is all we need.</p>
<p>There are situations when we need to do more than just adding keys to the <code>ENV</code> variable. Dotenv provides
an Instrumenter for Rails. Let’s take a look at the code</p>
<pre><code class="language-ruby"><span class="hljs-keyword">require</span> <span class="hljs-string">'dotenv'</span>

Dotenv.instrumenter = <span class="hljs-symbol">ActiveSupport:</span><span class="hljs-symbol">:Notifications</span>

<span class="hljs-comment"># Watch all loaded env files with Spring</span>
<span class="hljs-keyword">begin</span>
  <span class="hljs-keyword">require</span> <span class="hljs-string">'spring/watcher'</span>
  <span class="hljs-symbol">ActiveSupport:</span><span class="hljs-symbol">:Notifications</span>.subscribe(<span class="hljs-regexp">/^dotenv/</span>) <span class="hljs-keyword">do</span> |*args|
    event = <span class="hljs-symbol">ActiveSupport:</span><span class="hljs-symbol">:Notifications</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:Event</span>.new(*args)
    Spring.watch event.payload[<span class="hljs-symbol">:env</span>].filename <span class="hljs-keyword">if</span> Rails.application
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">rescue</span> LoadError
  <span class="hljs-comment"># Spring is not available</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># ...</span>
</code></pre>
<p>On line 3 it assigns <a href="http://edgeapi.rubyonrails.org/classes/ActiveSupport/Notifications.html">ActiveSupport::Notifications</a>
to <code>Dotenv.instrumenter</code>. <code>ActiveSupport::Notifications</code> responds to <code>instrument```and takes a</code>name<code>, a</code>payload<code>and a</code>block`.</p>
<p>I’m not 100% sure cause I didn’t have the time to dive deeper, but here is what I think this file does.
It listens to all the events that starts with _dotenv. _When it captures an event, it  generates an
<a href="http://edgeapi.rubyonrails.org/classes/ActiveSupport/Notifications/Event.html">ActiveSupport::Notifications::Event</a>
with the event informations (name, start, finish, id, payload). Then it takes the filename from the event
payload, and tells <code>Spring</code> to watch this file.</p>
<p>To better understand this last bit, let’s take another look at the how the <code>instrument</code> method is invoked.</p>
<pre><code class="language-ruby">instrument(<span class="hljs-string">'dotenv.load'</span>, <span class="hljs-symbol">:env</span> =&gt; env) { env.apply }
</code></pre>
<p>The name we pass to instrument is <em>dotenv.load</em>. It starts with <em>dotenv</em> so the subscriber will capture
this event. Then we pass a payload that is just an hash with a single key: env.
This key points to the <code>env</code> instance (remember, this is an instance of the <code>Environment</code> class).</p>
<p>The <code>Environment</code> class defines an <code>attr\_reader</code> called <code>filename</code> that returns the filename an <code>Environment</code>
object is initialized with.</p>
<p>That’s why we can call <code>event.payload\[:env\].filename</code>and get in return the configuration filename.</p>
<p>Actually this instrumenter for Rails does other stuff. It creates a
<a href="http://edgeapi.rubyonrails.org/classes/Rails/Railtie.html">Railtie</a> that is needed to setup a subscriber
with <code>ActiveSupport::Notifications</code>, but I won’t go into the details this time.
Maybe in the future when I understand this stuff better!</p>
<p>Anyway the file is commented pretty well and you can get the big picture.</p>
<pre><code class="language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Dotenv</span></span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Railtie</span> &lt; Rails::Railtie</span>
    config.before_configuration { load }

    <span class="hljs-comment"># Public: Load dotenv</span>
    <span class="hljs-comment">#</span>
    <span class="hljs-comment"># This will get called during the `before_configuration` callback, but you</span>
    <span class="hljs-comment"># can manually call `Dotenv::Railtie.load` if you needed it sooner.</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load</span></span>
      Dotenv.load(
        root.join(<span class="hljs-string">".env.local"</span>),
        root.join(<span class="hljs-string">".env.<span class="hljs-subst">#{Rails.env}</span>"</span>),
        root.join(<span class="hljs-string">'.env'</span>)
      )
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment"># Internal: `Rails.root` is nil in Rails 4.1 before the application is</span>
    <span class="hljs-comment"># initialized, so this falls back to the `RAILS_ROOT` environment variable,</span>
    <span class="hljs-comment"># or the current working directory.</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">root</span></span>
      Rails.root || Pathname.new(ENV[<span class="hljs-string">"RAILS_ROOT"</span>] || Dir.pwd)
    <span class="hljs-keyword">end</span>

    <span class="hljs-comment"># Rails uses `#method_missing` to delegate all class methods to the</span>
    <span class="hljs-comment"># instance, which means `Kernel#load` gets called here. We don't want that.</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">load</span></span>
      instance.load
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2>What we’ve learned</h2>
<ol>
<li><code>Hash\#update</code> – it is an alias for <code>merge</code>. Merges two hashes and overrides existing keys with the ones found into the hash passed in.</li>
<li><code>Blocks</code> can be used to provide default behaviour to a method. Kinda like when you provide a Policy or a Strategy object to change the behaviour of a process.</li>
<li><code>ActiveSupport::Notifications</code> – You can use them to subscribe to events fired by instrumenter (both from Rails or other gems).</li>
</ol>
<p>I want to give a special thanks to my buddy Alex Pedini who proof reads these posts every week. Thank you!</p>
<p>P.S.: He is a terrific musician. Check out his <a href="https://www.youtube.com/user/gotenks82">YouTube channel</a></p>
<p>Happy coding!</p>

          </article>
        </div>
      </div>
    </div>

    <!-- jQuery for Bootstrap -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<!-- Bootstrap -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
  </body>
</html>

